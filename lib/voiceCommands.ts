/**
 * üé§ VOICE COMMANDS SYSTEM - Sistema de Comandos de Voz para Carteiros
 * Hands-free operation para uso durante entregas
 */

export interface VoiceCommand {
  patterns: string[];
  action: string;
  description: string;
  category: 'navigation' | 'delivery' | 'system';
  requiresConfirmation?: boolean;
}

export interface VoiceResponse {
  text: string;
  priority: 'low' | 'medium' | 'high';
  interrupt?: boolean; // Interrompe outras falas
}

export class VoiceCommandSystem {
  private recognition: SpeechRecognition | null = null;
  private synthesis: SpeechSynthesis;
  private isListening = false;
  private isEnabled = false;
  private currentUtterance: SpeechSynthesisUtterance | null = null;
  
  // Callbacks para a√ß√µes
  private onCommand: ((command: string, params?: any) => void) | null = null;
  private onListeningChange: ((listening: boolean) => void) | null = null;
  private onError: ((error: string) => void) | null = null;

  // üé§ COMANDOS DISPON√çVEIS
  private commands: VoiceCommand[] = [
    // NAVEGA√á√ÉO
    {
      patterns: ['pr√≥xima entrega', 'pr√≥xima parada', 'pr√≥ximo endere√ßo', 'continuar'],
      action: 'next_delivery',
      description: 'Ir para pr√≥xima entrega',
      category: 'navigation'
    },
    {
      patterns: ['entrega anterior', 'parada anterior', 'voltar'],
      action: 'previous_delivery',
      description: 'Voltar para entrega anterior',
      category: 'navigation'
    },
    {
      patterns: ['mostrar mapa', 'abrir mapa', 'ver rota'],
      action: 'show_map',
      description: 'Exibir mapa da rota',
      category: 'navigation'
    },
    {
      patterns: ['iniciar rota', 'come√ßar entrega', 'navegar'],
      action: 'start_route',
      description: 'Iniciar navega√ß√£o no Google Maps',
      category: 'navigation'
    },

    // CONTROLE DE ENTREGAS
    {
      patterns: ['entregue', 'entrega realizada', 'conclu√≠do', 'feito'],
      action: 'mark_delivered',
      description: 'Marcar entrega como realizada',
      category: 'delivery',
      requiresConfirmation: true
    },
    {
      patterns: ['problema', 'erro', 'n√£o encontrei', 'endere√ßo errado'],
      action: 'report_problem',
      description: 'Reportar problema na entrega',
      category: 'delivery'
    },
    {
      patterns: ['pular entrega', 'pular parada', 'deixar para depois'],
      action: 'skip_delivery',
      description: 'Pular entrega atual',
      category: 'delivery',
      requiresConfirmation: true
    },
    {
      patterns: ['pausar', 'parar', 'intervalo'],
      action: 'pause_route',
      description: 'Pausar rota para intervalo',
      category: 'delivery'
    },

    // SISTEMA
    {
      patterns: ['ajuda', 'comandos', 'o que posso falar'],
      action: 'show_help',
      description: 'Mostrar comandos dispon√≠veis',
      category: 'system'
    },
    {
      patterns: ['estat√≠sticas', 'dashboard', 'm√©tricas'],
      action: 'show_dashboard',
      description: 'Abrir dashboard de estat√≠sticas',
      category: 'system'
    },
    {
      patterns: ['silenciar', 'calar', 'parar de falar'],
      action: 'stop_speaking',
      description: 'Parar s√≠ntese de voz',
      category: 'system'
    },
    {
      patterns: ['repetir', 'falar novamente', 'n√£o entendi'],
      action: 'repeat_last',
      description: 'Repetir √∫ltima informa√ß√£o',
      category: 'system'
    }
  ];

  private lastResponse: VoiceResponse | null = null;

  constructor() {
    if (typeof window !== 'undefined') {
      this.synthesis = window.speechSynthesis;
      this.initializeRecognition();
    }
  }

  /**
   * üé§ Inicializar reconhecimento de voz
   */
  private initializeRecognition(): void {
    if (typeof window === 'undefined' || (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window))) {
      console.warn('üé§ Speech Recognition n√£o suportado neste navegador');
      return;
    }

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    this.recognition = new SpeechRecognition();

    // Configura√ß√µes otimizadas para ambiente de tr√¢nsito
    this.recognition.continuous = true;
    this.recognition.interimResults = false;
    this.recognition.lang = 'pt-BR';
    this.recognition.maxAlternatives = 3; // M√∫ltiplas alternativas para melhor precis√£o

    // Event listeners
    this.recognition.onstart = () => {
      this.isListening = true;
      this.onListeningChange?.(true);
      console.log('üé§ Escutando comandos de voz...');
    };

    this.recognition.onend = () => {
      this.isListening = false;
      this.onListeningChange?.(false);
      
      // Reiniciar automaticamente se ainda estiver habilitado
      if (this.isEnabled) {
        setTimeout(() => this.startListening(), 1000);
      }
    };

    this.recognition.onresult = (event) => {
      const results = Array.from(event.results);
      const lastResult = results[results.length - 1];
      
      if (lastResult.isFinal) {
        const transcript = lastResult[0].transcript.toLowerCase().trim();
        console.log('üé§ Comando detectado:', transcript);
        this.processCommand(transcript);
      }
    };

    this.recognition.onerror = (event) => {
      console.error('üé§ Erro no reconhecimento:', event.error);
      
      // Tratamento espec√≠fico de erros
      switch (event.error) {
        case 'no-speech':
          // Ignorar - normal em ambiente ruidoso
          break;
        case 'audio-capture':
          this.onError?.('Microfone n√£o dispon√≠vel');
          break;
        case 'not-allowed':
          this.onError?.('Permiss√£o de microfone negada');
          break;
        default:
          this.onError?.(`Erro de reconhecimento: ${event.error}`);
      }
    };
  }

  /**
   * üé§ Processar comando de voz
   */
  private processCommand(transcript: string): void {
    const normalizedTranscript = this.normalizeText(transcript);
    
    // Buscar comando correspondente
    const matchedCommand = this.findMatchingCommand(normalizedTranscript);
    
    if (matchedCommand) {
      console.log('‚úÖ Comando reconhecido:', matchedCommand.action);
      
      if (matchedCommand.requiresConfirmation) {
        this.requestConfirmation(matchedCommand, transcript);
      } else {
        this.executeCommand(matchedCommand.action);
      }
    } else {
      console.log('‚ùå Comando n√£o reconhecido:', transcript);
      this.speak({
        text: 'Comando n√£o reconhecido. Diga "ajuda" para ver os comandos dispon√≠veis.',
        priority: 'medium'
      });
    }
  }

  /**
   * üîç Encontrar comando correspondente
   */
  private findMatchingCommand(transcript: string): VoiceCommand | null {
    for (const command of this.commands) {
      for (const pattern of command.patterns) {
        if (this.matchesPattern(transcript, pattern)) {
          return command;
        }
      }
    }
    return null;
  }

  /**
   * üéØ Verificar se texto corresponde ao padr√£o
   */
  private matchesPattern(text: string, pattern: string): boolean {
    const normalizedText = this.normalizeText(text);
    const normalizedPattern = this.normalizeText(pattern);
    
    // Correspond√™ncia exata
    if (normalizedText === normalizedPattern) return true;
    
    // Correspond√™ncia parcial (cont√©m todas as palavras-chave)
    const patternWords = normalizedPattern.split(' ');
    const textWords = normalizedText.split(' ');
    
    return patternWords.every(word => 
      textWords.some(textWord => 
        textWord.includes(word) || word.includes(textWord)
      )
    );
  }

  /**
   * üßπ Normalizar texto para compara√ß√£o
   */
  private normalizeText(text: string): string {
    return text
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove acentos
      .replace(/[^\w\s]/g, '') // Remove pontua√ß√£o
      .trim();
  }

  /**
   * ‚ùì Solicitar confirma√ß√£o para comandos cr√≠ticos
   */
  private requestConfirmation(command: VoiceCommand, originalTranscript: string): void {
    this.speak({
      text: `Confirma: ${command.description}? Diga "sim" ou "n√£o".`,
      priority: 'high',
      interrupt: true
    });

    // Aguardar confirma√ß√£o por 5 segundos
    const confirmationTimeout = setTimeout(() => {
      this.speak({
        text: 'Comando cancelado por timeout.',
        priority: 'medium'
      });
    }, 5000);

    // Listener tempor√°rio para confirma√ß√£o
    const confirmationListener = (event: any) => {
      const results = Array.from(event.results);
      const lastResult = results[results.length - 1];
      
      if (lastResult.isFinal) {
        const response = lastResult[0].transcript.toLowerCase().trim();
        clearTimeout(confirmationTimeout);
        
        if (response.includes('sim') || response.includes('confirmo')) {
          this.executeCommand(command.action);
          this.speak({
            text: 'Comando executado.',
            priority: 'medium'
          });
        } else {
          this.speak({
            text: 'Comando cancelado.',
            priority: 'medium'
          });
        }
        
        // Remover listener tempor√°rio
        this.recognition?.removeEventListener('result', confirmationListener);
      }
    };

    this.recognition?.addEventListener('result', confirmationListener);
  }

  /**
   * ‚ö° Executar comando
   */
  private executeCommand(action: string): void {
    this.onCommand?.(action);
  }

  /**
   * üîä S√≠ntese de voz
   */
  speak(response: VoiceResponse): void {
    // Interromper fala atual se necess√°rio
    if (response.interrupt && this.currentUtterance) {
      this.synthesis.cancel();
    }

    // Aguardar s√≠ntese estar pronta
    if (this.synthesis.speaking) {
      setTimeout(() => this.speak(response), 100);
      return;
    }

    const utterance = new SpeechSynthesisUtterance(response.text);
    
    // Configura√ß√µes otimizadas para ambiente ruidoso
    utterance.lang = 'pt-BR';
    utterance.rate = 0.9; // Falar um pouco mais devagar
    utterance.pitch = 1.1; // Tom ligeiramente mais alto
    utterance.volume = 1.0; // Volume m√°ximo

    // Priorizar voz feminina (geralmente mais clara)
    const voices = this.synthesis.getVoices();
    const portugueseVoice = voices.find(voice => 
      voice.lang.startsWith('pt') && voice.name.toLowerCase().includes('female')
    ) || voices.find(voice => voice.lang.startsWith('pt'));
    
    if (portugueseVoice) {
      utterance.voice = portugueseVoice;
    }

    utterance.onstart = () => {
      this.currentUtterance = utterance;
    };

    utterance.onend = () => {
      this.currentUtterance = null;
    };

    this.synthesis.speak(utterance);
    this.lastResponse = response;
  }

  /**
   * üé§ Iniciar escuta
   */
  startListening(): void {
    if (!this.recognition) {
      this.onError?.('Reconhecimento de voz n√£o dispon√≠vel');
      return;
    }

    if (this.isListening) return;

    try {
      this.isEnabled = true;
      this.recognition.start();
    } catch (error) {
      console.error('Erro ao iniciar reconhecimento:', error);
      this.onError?.('Erro ao iniciar reconhecimento de voz');
    }
  }

  /**
   * üõë Parar escuta
   */
  stopListening(): void {
    this.isEnabled = false;
    if (this.recognition && this.isListening) {
      this.recognition.stop();
    }
  }

  /**
   * üîá Parar s√≠ntese de voz
   */
  stopSpeaking(): void {
    this.synthesis.cancel();
    this.currentUtterance = null;
  }

  /**
   * üìã Obter comandos dispon√≠veis
   */
  getAvailableCommands(): VoiceCommand[] {
    return this.commands;
  }

  /**
   * üîÑ Repetir √∫ltima resposta
   */
  repeatLast(): void {
    if (this.lastResponse) {
      this.speak(this.lastResponse);
    } else {
      this.speak({
        text: 'Nenhuma informa√ß√£o para repetir.',
        priority: 'medium'
      });
    }
  }

  /**
   * üìû Configurar callbacks
   */
  setCallbacks(callbacks: {
    onCommand?: (command: string, params?: any) => void;
    onListeningChange?: (listening: boolean) => void;
    onError?: (error: string) => void;
  }): void {
    this.onCommand = callbacks.onCommand || null;
    this.onListeningChange = callbacks.onListeningChange || null;
    this.onError = callbacks.onError || null;
  }

  /**
   * üßπ Cleanup
   */
  destroy(): void {
    this.stopListening();
    this.stopSpeaking();
    this.recognition = null;
  }
}

// Inst√¢ncia singleton
export const voiceCommands = new VoiceCommandSystem();
